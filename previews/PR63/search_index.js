var documenterSearchIndex = {"docs":
[{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"EditURL = \"simulate_ideal_pulses_lit.jl\"","category":"page"},{"location":"tutorials/simulate_ideal_pulses/#Simulate-Ideal-Pulses","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"","category":"section"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"You can also download this tutorial as a Jupyter notebook and a plain Julia source file.","category":"page"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"Here we will use an example pet file csv format from LegendTestData corresponding to the Public Inverted Coax.","category":"page"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"using LegendGeSim\nusing Plots","category":"page"},{"location":"tutorials/simulate_ideal_pulses/#Get-inputs-from-legend-test-data","page":"Simulate Ideal Pulses","title":"Get inputs from legend-test-data","text":"","category":"section"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"using LegendTestData","category":"page"},{"location":"tutorials/simulate_ideal_pulses/#Detector-metadata","page":"Simulate Ideal Pulses","title":"Detector metadata","text":"","category":"section"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"ldsim_path = joinpath(legend_test_data_path(), \"data\", \"ldsim\")\n\ndetector_name = \"invcoax-metadata\"\ndetector_metadata_filename = joinpath(ldsim_path, detector_name*\".json\");\nnothing #hide","category":"page"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"Alternatively, enter your own path to a real LEGEND detector JSON","category":"page"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"detector_metadata_filename = \"path/to/V04545A.json\"","category":"page"},{"location":"tutorials/simulate_ideal_pulses/#PET-input-file","page":"Simulate Ideal Pulses","title":"PET input file","text":"","category":"section"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"path_to_pet_file = joinpath(ldsim_path, \"single-invcoax-th228-geant4.csv\");\nnothing #hide","category":"page"},{"location":"tutorials/simulate_ideal_pulses/#Settings","page":"Simulate Ideal Pulses","title":"Settings","text":"","category":"section"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"See manual on Field Simulation and Ideal Pulse Simulation for a detailed explanation of environment and simulation settings, as well as the noise model settings","category":"page"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"environment_settings = Dict(\n    \"crystal_temperature_in_K\" => 77,\n    \"medium\" => \"vacuum\",\n);\nnothing #hide","category":"page"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"Simple settings for point charge simulation with dummy constant impurity","category":"page"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"simulation_settings = Dict(\n    \"method\" => \"SSD\",\n    \"cached_name\" => \"\", # a non-empty string will cache the simulation results\n);\nnothing #hide","category":"page"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"noise_model = Dict(\n    \"type\" => \"sim\"\n);\n\n# Simulate ideal pulses","category":"page"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"Provide an optional argument n_waveforms to define the number of pulses to be simulated. Default: all pulses based on the input file","category":"page"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"pss_table, pss_truth = LegendGeSim.simulate_pulses(detector_metadata_filename, path_to_pet_file, environment_settings, simulation_settings; n_waveforms=5);\nnothing #hide","category":"page"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"plot(pss_table.waveform, legend=false, linewidth=1.5)","category":"page"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"The \"negative\" waveforms are the ones coming from the n+ contact, so they are symmetric. In fact, the length of our table is twice the amount of waveforms we simulated.","category":"page"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"length(pss_table)","category":"page"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"plot(pss_table.waveform[1:5], legend=false, title=\"only p+ contact pulses\")\n\nsavefig(\"ideal_pulses.svg\"); nothing # hide","category":"page"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"(Image: ideal_pulses)","category":"page"},{"location":"tutorials/simulate_ideal_pulses/#Save-output-to-hdf5-file","page":"Simulate Ideal Pulses","title":"Save output to hdf5 file","text":"","category":"section"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"You can save simulated pulses in a file that can be used later.","category":"page"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"using LegendHDF5IO","category":"page"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"pss_name = \"cache/test_100wfs_pss.hdf5\"\nlh5open(pss_name, \"w\") do f\n    LegendHDF5IO.writedata(f.data_store, \"pss/pss\", pss_table[1:5])\n    LegendHDF5IO.writedata(f.data_store, \"pss/truth\", pss_truth[1:5])\nend","category":"page"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"","category":"page"},{"location":"tutorials/simulate_ideal_pulses/","page":"Simulate Ideal Pulses","title":"Simulate Ideal Pulses","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/field_simulation/#Field-Simulation","page":"Field Simulation","title":"Field Simulation","text":"","category":"section"},{"location":"man/field_simulation/","page":"Field Simulation","title":"Field Simulation","text":"As inputs to field simulation you should provide","category":"page"},{"location":"man/field_simulation/","page":"Field Simulation","title":"Field Simulation","text":"LEGEND detector metadata\nEnvironment settings\nSimulation settings","category":"page"},{"location":"man/field_simulation/#Example","page":"Field Simulation","title":"Example","text":"","category":"section"},{"location":"man/field_simulation/","page":"Field Simulation","title":"Field Simulation","text":"detector_metadata_filename = \"path/to/legend-detectors/germanium/diodes/V04545A.json\"\n\nenvironment_settings = Dict(\n    \"crystal_temperature_in_K\" => 77, \n    \"medium\" => \"vacuum\", \n    \"dl\" => \"vendor\" # optional, default 0\n    \"operating_voltage_in_V\" => 5000, # optional, default recV from metadata\n)\n\nsimulation_settings = Dict(\n    \"method\" => \"SSD\",\n    \"cached_name\" => \"test\",\n    \"crystal_metadata_path\" => \"path/to/legend-detectors/germanium/crystals\"\n)\n\nsim = LegendGeSim.simulate_fields(detector_metadata_filename, environment_settings, simulation_settings; overwrite=true)","category":"page"},{"location":"man/field_simulation/","page":"Field Simulation","title":"Field Simulation","text":"Provide an optional argument overwrite to overwrite an existing file with the same cached_name. Default: false","category":"page"},{"location":"man/field_simulation/","page":"Field Simulation","title":"Field Simulation","text":"In case of SSD as method, the output of simulate_fields() is a Simulation object from SolidSateDetectors.jl. Among other things, it contains a SolidStateDetector object under sim.detector. See the short tutorial on how to Visualize Detector Geometry using this object.","category":"page"},{"location":"man/field_simulation/","page":"Field Simulation","title":"Field Simulation","text":"In case of siggen as method, the output of simulate_fields() is a SigGenSetup object from MJDSigGen.jl containing information needed for the siggen simulation. It is possible to extract the electric and weighting potential from this object and plot it (see tutotorial Simulate Fields).","category":"page"},{"location":"man/field_simulation/#1.-LEGEND-detector-metadata","page":"Field Simulation","title":"1. LEGEND detector metadata","text":"","category":"section"},{"location":"man/field_simulation/","page":"Field Simulation","title":"Field Simulation","text":"To obtain JSONs for all LEGEND detectors you can clone the repository legend-detectors. The JSONs can be found under germanium/diodes. You may also create your custom detector JSON file as long as it follows the LEGEND detector metadata format (see README in diodes/).","category":"page"},{"location":"man/field_simulation/#2.-Environment-settings","page":"Field Simulation","title":"2. Environment settings","text":"","category":"section"},{"location":"man/field_simulation/","page":"Field Simulation","title":"Field Simulation","text":"Environment settings contain:","category":"page"},{"location":"man/field_simulation/","page":"Field Simulation","title":"Field Simulation","text":"\"crystal_temperature_in_K\": crystal temperature in units of Kelvin e.g. 77 for liquid nitrogen, 90 for LAr\n\"medium\": \"vacuum\" or \"LAr\" (note: the LAr option has actually never been tested yet)\n\"operating_voltage_in_V\": bias voltage at the n+ contact in units of Volts\nIf you do not provide this field in the environment settings, the value from characterization.l200_site.recommended_voltage_in_V in detector metadata JSON will be taken.\n\"dl\": dead layer (DL) thickness in mm.\nThis is not really part of \"environment\" but is added as a temporary quickfix for now to be able to study DL effects. In the future might be moved to simulation settings (see below).\nProvide a value e.g. \"dl\" => 1.2. If you do not provide this setting at all, default 0 will be taken\nProviding \"dl\" => \"vendor\" means the value from characterization.manufacturer.dl_thickness_in_mm in detector metadata JSON file will be taken.","category":"page"},{"location":"man/field_simulation/#3.-Simulation-settings","page":"Field Simulation","title":"3. Simulation settings","text":"","category":"section"},{"location":"man/field_simulation/","page":"Field Simulation","title":"Field Simulation","text":"Simulation settings contain:","category":"page"},{"location":"man/field_simulation/","page":"Field Simulation","title":"Field Simulation","text":"\"method\": \"SSD\" (or \"ssd\") or \"siggen\" (or \"fieldgen\")\nBased on the given method, LegendGeSim will automatically construct configurations for either method based on the detector metadata, environment, and simulation settings\n\"cached_name\": if provided, your simulation will be cached in a file for future uses in a directory cache/ (will be created if not present)\nFormat:\ncache/<detector name>_<cached_name>_SSD.h5f file for SSD\ncache/<detector_name>_<cached_name>_fieldgen_WP.dat and *_EV.dat files for siggen.\nIn case of siggen, a siggen config named cache/<detector_name>_<cached_name>_siggen_config.txt will also be saved (generated based on given settings and geometry).\nThe detector name is taken from the detector metadata JSON \"name\" field.\nIf cached name is not provided (or \"\" is provided), the simulation will not be cached (for siggen will create a temporary config file).\nIt may be convenient to compose the cached_name in the simulation settings based on environment settings, varying detector geometry etc.\n\"crystal_metadata_path\": path to folder with crystal metadata JSONs.\nTo obtain JSONs for LEGEND crystals you can clone the repository legend-detectors. The JSONs can be found under germanium/crystals. You may also create your custom crystal JSON file as long as it follows the LEGEND crystal metadata format (see README in crystals/).\nThe crystal corresponding to your detector will be chosen from the given path based on the \"name\" field in the detector JSON. E.g. if your detector \"name\" field states \"V04545A\", LegendGeSim will be looking for a file \"V04545.json\".\nThe impurity profile will be constructed by fitting the impurity measurement points in the JSON using David Radford's function a + b*z + c*exp((L - z)/tau) (in crystal axis coordinates, later converted to detector axis). In case of SSD, the profile will be provided to the simulation internally, while for siggen, an input file will be created in siggen format (e.g. \"cache/V04545.dat\"). In either case, the position of the detector in the crystal is determined by the offset field contained in the crystal metadata.\nFor SSD, if no crystal metadata path is provided (or \"\" is provided), a dummy constant impurity of 10⁹ e/cm³ will be used.","category":"page"},{"location":"man/field_simulation/","page":"Field Simulation","title":"Field Simulation","text":"Alternative options for siggen: rather than providing a path to the crystal metadata folder and implementing impurity profile as described above, you may instead provide two inputs as is traditionally done when running siggen:","category":"page"},{"location":"man/field_simulation/","page":"Field Simulation","title":"Field Simulation","text":"\"impurity_profile\": path to a .dat file with the impurity profile (unformatted stream of Float32 of impurity values in units of 10¹⁰ e/cm³ with a step of 1 mm from tail end)\n\"offset_in_mm\": offset of the detector from tail end in mm","category":"page"},{"location":"man/field_simulation/","page":"Field Simulation","title":"Field Simulation","text":"If neither \"crystal_metadata_path\" not these settings are provided for siggen, a dummy constant impurity will be used as described above.","category":"page"},{"location":"man/field_simulation/","page":"Field Simulation","title":"Field Simulation","text":"Optional settings for siggen:","category":"page"},{"location":"man/field_simulation/","page":"Field Simulation","title":"Field Simulation","text":"\"fieldgen_config\": path to a siggen format config with \"extra\" settings e.g. crystal grid. Default examples/configs/fieldgen_settings.txt (in LegendGeSim). Note: in case of no crystal impurity profile input, a dummy constant impurity that is used is written in this file. In the future, all other optional fieldgen settings will be incorporated into the simulation settings input via LegendGeSim.\n\"drift_vel\": path to siggen format drift velocity file. Default examples/configs/drift_vel_tcorr.tab (in LegendGeSim)","category":"page"},{"location":"man/field_simulation/","page":"Field Simulation","title":"Field Simulation","text":"WARNING","category":"page"},{"location":"man/field_simulation/","page":"Field Simulation","title":"Field Simulation","text":"The implementation here is kind of janky, and if you want to read from a cached file, in theory you should only need to provide the cached name. However, for now it will also ask you to provide the other non-optional fields as well, and even worse - it will print out those settings first, and only then figure out that there's a cached file.","category":"page"},{"location":"man/field_simulation/","page":"Field Simulation","title":"Field Simulation","text":"This will of course be fixed in the future to not require those inputs, and possibly issue a warning if a cache file exists but settings are provided etc.","category":"page"},{"location":"man/field_simulation/","page":"Field Simulation","title":"Field Simulation","text":"However, even after that, if you provide certain inputs like temperature and crystal metadata path and a cached name that already exists, that cached file will be read even if the simulation there does no correspond to your other inputs, unless you provide overwrite=true to overwrite that file. For now at least, it is the user's job to remember which settings were used for the cached simulation.","category":"page"},{"location":"man/field_simulation/","page":"Field Simulation","title":"Field Simulation","text":"User suggestions are very welcome on how to manage this better    ","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:module]","category":"page"},{"location":"api/#Types-and-constants","page":"API","title":"Types and constants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type, :constant]","category":"page"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:macro, :function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [LegendGeSim]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"api/#LegendGeSim.LegendGeSim","page":"API","title":"LegendGeSim.LegendGeSim","text":"LegendGeSim\n\nTemplate for Julia packages.\n\n\n\n\n\n","category":"module"},{"location":"api/#LegendGeSim.CC4","page":"API","title":"LegendGeSim.CC4","text":"CC4 circuit model (ToDo)\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendGeSim.DAQ","page":"API","title":"LegendGeSim.DAQ","text":"The DAQ supertype corresponds to the component of the      DAQ and electronics setup that saves the waveform after      it triggered\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendGeSim.DAQ-Tuple{PropDicts.PropDict}","page":"API","title":"LegendGeSim.DAQ","text":"DAQ(sim_conf)\n\nLegendGeSimConfig -> <DAQ>\n\nConstruct a DAQ supertype struct based on given simulation configuration. Type of returned instance depends on settings in <sim_conf> Currently only one type of DAQ available (GenericDAQ),     rendering this function temporarily redundant.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.ElecChain","page":"API","title":"LegendGeSim.ElecChain","text":"The ElecChain supertype corresponds to the chain of      electronic components involved in the DAQ setup     that appear before the trigger.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendGeSim.ElecChain-Tuple{PropDicts.PropDict}","page":"API","title":"LegendGeSim.ElecChain","text":"ElecChain(sim_conf)\n\nLegendGeSimConfig -> <ElecChain>\n\nConstruct an ElecChain supertype struct based on given simulation configuration. Type of returned instance depends on settings in <sim_conf> Currently only one type of ElecChain available (GenericElecChain),     rendering this function temporarily redundant.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.Environment-Tuple{PropDicts.PropDict}","page":"API","title":"LegendGeSim.Environment","text":"Simulation parameters related to the environment\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.FADC","page":"API","title":"LegendGeSim.FADC","text":"The FADC supertype corresponds to the FADC component     of the electronics chain in the DAQ setup.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendGeSim.FADC-Tuple{PropDicts.PropDict}","page":"API","title":"LegendGeSim.FADC","text":"FADC(sim_conf)\n\nLegendGeSimConfig -> <FADC>\n\nConstruct an FADC supertype instance based on simulation     configuration <simconf>. Type of <FADC> depends on the type specified in <simconf>     (e.g. generic, Flashcam, Struck)\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.Flashcam","page":"API","title":"LegendGeSim.Flashcam","text":"FADC with Flashcam algorithm (ToDo)\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendGeSim.GenericDAQ","page":"API","title":"LegendGeSim.GenericDAQ","text":"GenericDAQ is a dummy DAQ model that stores the waveform     after it triggered, saving <baseline_length> samples before the     trigger index, and in total <nsamples> samples from start to end\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendGeSim.GenericDAQ-Tuple{PropDicts.PropDict}","page":"API","title":"LegendGeSim.GenericDAQ","text":"GenericDAQ(sim_conf)\n\nLegendGeSimConfig -> GenericDAQ \n\nConstruct a GenericDAQ struct based on given simulation configuration \n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.GenericElecChain","page":"API","title":"LegendGeSim.GenericElecChain","text":"Generic electronics chain consisting of a preamplifier     and an FADC module\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendGeSim.GenericElecChain-Tuple{PropDicts.PropDict}","page":"API","title":"LegendGeSim.GenericElecChain","text":"GenericElecChain(sim_conf)\n\nLegendGeSimConfig -> GenericElecChain\n\nConstruct electronics components based on simulation      configuration <sim_conf> and create a GenericChain instance     based on these components.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.GenericFADC","page":"API","title":"LegendGeSim.GenericFADC","text":"GenericFADC is a dummy FADC model that performs sampling     of the input waveform based on the sampling interval <Δt>\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendGeSim.GenericFADC-Tuple{PropDicts.PropDict}","page":"API","title":"LegendGeSim.GenericFADC","text":"GenericFADC(sim_conf)\n\nLegendGeSimConfig -> GenericFADC\n\nConstruct a GenericFADC instance based on simulation     configuration <sim_conf>\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.GenericPreAmp","page":"API","title":"LegendGeSim.GenericPreAmp","text":"The GenericPreAmp is a dummy PreAmp model that accounts for     effects such as decay and rise time, offset, noise and gain.\n\nThis dummy model involves no real electronics response, only gain.\n\nThis struct is currently mutable because in the case of noise modelling based on data,     the gain has to match the one in the baselines extracted from data,     so in that case the PreAmp is initialized with gain = 0, and the gain     is calculated later. I assume this is temporary, as the user should know which     gain / max_e the data was produced with and give it as simulation input.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendGeSim.GenericPreAmp-Tuple{PropDicts.PropDict}","page":"API","title":"LegendGeSim.GenericPreAmp","text":"GenericPreAmp(sim_conf)\n\nLegendGeSimConfig -> GenericPreAmp    \n\nConstruct a GenericPreAmp instance based on given simulation configuration <sim_conf>\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.NoiseFromData","page":"API","title":"LegendGeSim.NoiseFromData","text":"The NoiseFromData model means instead of simulating given      preamp noise, and also gain and offset, these parameters will be     accounted for or inferred from real data baselines     contained in the <baseline_catalog>\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendGeSim.NoiseFromData-Tuple{PropDicts.PropDict}","page":"API","title":"LegendGeSim.NoiseFromData","text":"NoiseFromData(sim_conf)\n\nLegendGeSimConfig -> NoiseFromData \n\nConstruct a NoiseFromData struct based on given simulation configuration <sim_conf>\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.NoiseFromSim","page":"API","title":"LegendGeSim.NoiseFromSim","text":"The NoiseFromSim model means simulating noise from scratch     starting from fano noise of the germanium crystal     and ending with noise coming from electronics components.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendGeSim.NoiseModel","page":"API","title":"LegendGeSim.NoiseModel","text":"The NoiseModel supertype corresponds to different methods     of simulating noise coming from the electronics chain     components.\n\nIt is not simply a string in the ElecChain struct because     it must exist as a separate instance for the stp->pss step      that is independent from the elec simulation, but has to know     what type of noise model is used to deal with fano noise.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendGeSim.NoiseModel-Tuple{PropDicts.PropDict}","page":"API","title":"LegendGeSim.NoiseModel","text":"NoiseModel(sim_config)\n\nLegendGeSimConfig -> <NoiseModel>\n\nConstuct a NoiseModel supertype instance based on simulation settings      given in <simconfig> Type of <NoiseModel> depends on <simconfig> settings.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.PSSimulator","page":"API","title":"LegendGeSim.PSSimulator","text":"The PSSimulator supertype defines what type of method      is used for the simulation of electric field and weighting potential,     calculation of detector capacitance etc., as well as simulation of current pulses\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendGeSim.PreAmp","page":"API","title":"LegendGeSim.PreAmp","text":"The PreAmp supertype corresponds to the charge sensitive preamplifier component\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendGeSim.PreAmp-Tuple{PropDicts.PropDict}","page":"API","title":"LegendGeSim.PreAmp","text":"PreAmp(sim_conf)\n\nLegendGeSimConfig -> <PreAmp>    \n\nConstruct a PreAmp supertype instance based on given simulation configuration <simconf>. Returned type depends on the settings in <simconf>. Currently only GenericPreAmp is available.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.SSDSimulator","page":"API","title":"LegendGeSim.SSDSimulator","text":"Simulation method: SolidStateDetectors\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendGeSim.SiggenSimulator","page":"API","title":"LegendGeSim.SiggenSimulator","text":"SSDSimulator(sim_conf)\n\nLegendGeSimConfig -> SSDSimulator\n\nConstruct SSDSimulator instance based on simulation     configuration given in <sim_conf>.\n\nCurrently SSDSimulator does not have any parameters\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendGeSim.Struck","page":"API","title":"LegendGeSim.Struck","text":"FADC with Struck algorithm (ToDo)\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendGeSim.TrapFilter","page":"API","title":"LegendGeSim.TrapFilter","text":"The TrapFilter trigger is a dummy simulation of the trapezoidal filter     algorithm to produce a trigger if the waveform amplitude passes     a certain threshold.\n\nThis struct is currently mutable because in case of NoiseFromData modelling,     we need to calculate the threshold post-factum after analysing the noise     levels in data.    \n\n\n\n\n\n","category":"type"},{"location":"api/#LegendGeSim.TrapFilter-Tuple{PropDicts.PropDict}","page":"API","title":"LegendGeSim.TrapFilter","text":"TrapFilter(sim_conf)\n\nLegendGeSimConfig -> TrapFilter \n\nConstruct a TrapFilter instance based on simulation configuration given in <sim_conf>.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.Trigger","page":"API","title":"LegendGeSim.Trigger","text":"The Trigger supertype corresponds to the trigger component in DAQ.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendGeSim.Trigger-Tuple{PropDicts.PropDict}","page":"API","title":"LegendGeSim.Trigger","text":"Trigger(sim_conf)\n\nLegendGeSimConfig -> <Trigger>    \n\nConstruct a Trigger supertype instance based on settings given in <sim_conf>. The returned type depends on the given settings.\n\nCurrently only TrapFilter type is implemented.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.add_tail_and_baseline-Tuple{RadiationDetectorSignals.RDWaveform, LegendGeSim.GenericFADC, LegendGeSim.GenericDAQ}","page":"API","title":"LegendGeSim.add_tail_and_baseline","text":"add_tail_and_baseline(wf, fadc, daq)\n\nRDWaveform, GenericFADC, GenericDAQ -> RDWaveform  \n\nExtend tail and add baseline of <wf> based on <fadc> and <daq> parameters.\n\nExtended conservatively to ensure enough samples for the future     sliding trap filter window and the resulting DAQ baseline.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.baseline_catalog-Tuple{AbstractString}","page":"API","title":"LegendGeSim.baseline_catalog","text":"baseline_catalog(raw_filename)\n\nAbstractString -> Table \n\nLook up stored table of baselines corresponding to given raw data <raw_filename>. If does not exist, construct such table.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.baseline_catalog-Tuple{TypedTables.Table}","page":"API","title":"LegendGeSim.baseline_catalog","text":"baseline_catalog(raw_table)\n\nTable -> Table \n\nConstruct table of baselines extracted from the waveforms     contained in the given raw data table <raw_table>\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.construct_ssd_simulation-Tuple{PropDicts.PropDict, LegendGeSim.Environment, LegendGeSim.SSDSimulator}","page":"API","title":"LegendGeSim.construct_ssd_simulation","text":"construct_ssd_simulation(det_meta, env, sim_settings)\n\nPropDict, Environment, SSDSimulator -> SSD.Simulation\n\nConstruct a SolidStateDetectors.Simulation based on geometry as given in LEGEND metadata det_meta and on envorinmental settings specified in env and on simulational settings specified in sim_settings.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.differentiate-Tuple{RadiationDetectorSignals.RDWaveform}","page":"API","title":"LegendGeSim.differentiate","text":"differentiate(wf)\n\nRDWaveform -> RDWaveform    \n\nDifferentiate a waveform using a Biquad filter\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.extend_baseline-Tuple{RadiationDetectorSignals.RDWaveform, RadiationDetectorSignals.RDWaveform}","page":"API","title":"LegendGeSim.extend_baseline","text":"extend_baseline(baseline, wf)\n\nRDWaveform, RDWaveform -> RDWaveform\n\nTake a given <baseline> and extend it to match the length (and sampling)             of the given waveform <wf>\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.fano_noise-Tuple{TypedTables.Table, PropDicts.PropDict, LegendGeSim.Environment, LegendGeSim.NoiseFromData}","page":"API","title":"LegendGeSim.fano_noise","text":"fano_noise(events, ::PropDict, ::Environment, ::NoiseFromData)\n\nTable -> Table    \n\nDo nothing since we do not need to simulate fano noise separately when      using data baselines to account for noise levels.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.fano_noise-Tuple{TypedTables.Table, PropDicts.PropDict, LegendGeSim.Environment, LegendGeSim.NoiseFromSim}","page":"API","title":"LegendGeSim.fano_noise","text":"fano_noise(events, det_meta, env, ::NoiseFromSim)\n\nTable, PropDict, Environment -> Table \n\nCalculate fano noise level based on the detector specification provided in     LEGEND metadata <det_meta> and environment settings provided in <env>,     and add it to given <events>\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.filename-Tuple{Any}","page":"API","title":"LegendGeSim.filename","text":"filename(path)\n\nSring -> String\n\nExtract core name of the file from path \n\nE.g. filename(\"/some/path/to/filename.ext\") -> \"filename\"\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.group_by_column-Tuple{TypedTables.Table, Symbol}","page":"API","title":"LegendGeSim.group_by_column","text":"group_by_column(table, colname)\n\nTypedTables.Table, Symbol -> TypedTables.Table \n\nGroup table <table> by given column <colname>.\n\nI think this function already exists somewhere. Gotta ask Oliver and maybe use that package instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.impurity_density_model-Tuple{PropDicts.PropDict, PropDicts.PropDict, Vector{Float64}, LegendGeSim.SSDSimulator}","page":"API","title":"LegendGeSim.impurity_density_model","text":"Convert fit parameters from crystal metadata units (1e9 e/cm^3 VS mm) into SSD units (e/m^3 VS m) and return SolidStateDetector impurity density type RadfordImpurityDensity to be later used when constructing SSD object.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.impurity_density_model-Tuple{PropDicts.PropDict}","page":"API","title":"LegendGeSim.impurity_density_model","text":"impurity_density_model(crystal_metadata)\n\nPropDict -> Vector{Float64}\n\nFit the impurity measurements in the crystal metadata with David Radford's empirical function a + bz + cexp((z-L)/tau) where z is crystal coordinate from seed end (z=0) to crystal length(z=L)\n\nThe fit is performed in crystal metadata coordinates i.e. distance in mm and impurity values in 1e9 e/cm^3 which determines the units of the parameters a,b,c,tau returned in the vector of Float32.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.pet_to_raw-Tuple{PropDicts.PropDict, AbstractString, Vararg{PropDicts.PropDict, 4}}","page":"API","title":"LegendGeSim.pet_to_raw","text":"pet_to_raw(pet_file_path, sim_config, config_name)\n\nAbstractString, PropDict, AbstractString -> Table\n\n[WIP] Full simulation chain pet->stp->pss->raw     based on simulated energy depositions contained in the HDF5 file     found in <petfilepath> and simulation settings given in <sim_config>.\n\nThe output name <config_name> is used to construct filenames for cached     simulation files (currently the same as the simulation config basename)\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.pet_to_stp-Union{Tuple{T}, Tuple{TypedTables.Table, SolidStateDetectors.SolidStateDetector{T}}} where T","page":"API","title":"LegendGeSim.pet_to_stp","text":"pet_to_stp(pet_table, detector_SSD)\n\nTable, SolidStateDetectors.Simulation -> Table\n\nConstruct a table with \"stepping info\" based on     position-energy-time information of simulated energy depositions     given in <pettable> and detector geometry given in <detectorSSD>.\n\nCurrent steps include:     - removing events outside of detector PV     - clustering     - grouping by detector     - removing events reconstructed to be outisde of the detector\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.preamp_gain-Tuple{LegendGeSim.GenericPreAmp, Union{LegendGeSim.NoiseFromSim, LegendGeSim.NoiseNone}}","page":"API","title":"LegendGeSim.preamp_gain","text":"preamp_gain(preamp, ::NoiseFromSim)\n\nGenericPreAmp -> Float64\n\nDo nothing and return original value of gain parameter in <preamp>,     since when NoiseFromSim model is used, gain is provided by the user     (or calculated based on user given max energy)    \n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.preamp_gain-Tuple{LegendGeSim.PreAmp, LegendGeSim.NoiseFromData}","page":"API","title":"LegendGeSim.preamp_gain","text":"preamp_gain(preamp, noise_model)\n\nGenericPreAmp, NoiseFromData -> Real\n\nCalculate gain of <preamp> based on its max energy and      the offset observed in data baselines contained in <noise_model>\n\nIn principle we should not do this in this simulation, and user has to provide      the precise parameters of the electronics chain used in producing data      the baselines from which are contained in <noise_model>.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.process_waveforms-Tuple{TypedTables.Table, LegendGeSim.GenericElecChain, LegendGeSim.Trigger, LegendGeSim.DAQ, LegendGeSim.NoiseModel}","page":"API","title":"LegendGeSim.process_waveforms","text":"process_waveforms(pss_table, elec_chain, trigger, daq, noise_model)\n\nTable, GenericElecChain, Trigger, DAQ, NoiseModel -> Table  \n\nSimulate effects of the electronics chain <elecchain>, <trigger> and <daq> settings     on the waveforms contained in <psstable>. Noise is simulated based on the given <noise_model>. The output table contains the resulting DAQ waveforms, simulated online energy after tigger,     baselines and their RMS, needed for the raw tier table.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.propdict-Tuple{AbstractString}","page":"API","title":"LegendGeSim.propdict","text":"propdict(json_file)\n\nAbstractString -> PropDict \n\nConstruct a PropDict based on given <json_file>. Alias for readprops from PropDicts.jl\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.pss_to_raw-Tuple{TypedTables.Table, TypedTables.Table, LegendGeSim.ElecChain, LegendGeSim.Trigger, LegendGeSim.DAQ, LegendGeSim.NoiseModel}","page":"API","title":"LegendGeSim.pss_to_raw","text":"pss_to_raw(pss_table, pss_truth, simulation_settings, elec_chain, trigger, daq, noise_model)\n\nTable, Table, SSDSimulator, ElecChain, Trigger, DAQ, NoiseModel -> Table\n\nSimulate effects of the electronics chain <elecchain>, <trigger> and <daq> settings     on the waveforms contained in <psstable>. Noise is simulated based on the given <noisemodel>. Construct a table with the format identical to data raw tier. Currently timing information in <psstruth> is used for dummy timestamps in the output     raw tier table.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.read_pet-Tuple{AbstractString}","page":"API","title":"LegendGeSim.read_pet","text":"AbstractString -> Table\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.remove_negative-Tuple{T} where T<:Real","page":"API","title":"LegendGeSim.remove_negative","text":"remove_negative(value)\n\nReal -> Real \n\nReplace negative values by zeros.\n\nUsed to remove a glitch in SSD pulses as a quick fix     while the glitch is being debugged.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.simulate-Tuple{RadiationDetectorSignals.RDWaveform, LegendGeSim.ElecChain, Union{LegendGeSim.NoiseFromSim, LegendGeSim.NoiseNone}}","page":"API","title":"LegendGeSim.simulate","text":"simulate(wf, elec_chain, ::NoiseFromSim)\n\nRDWaveform, ElecChain -> RDWaveform\n\nSimulate effects of the electronics chain on the waveform     modelling noise based on each component.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.simulate-Tuple{RadiationDetectorSignals.RDWaveform, LegendGeSim.ElecChain}","page":"API","title":"LegendGeSim.simulate","text":"simulate(wf, elec_chain)\n\nRDWaveform, ElecChain -> RDWaveform\n\nSimulate effects of the electronics chain components on the waveform.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.simulate-Tuple{RadiationDetectorSignals.RDWaveform, LegendGeSim.GenericElecChain, LegendGeSim.NoiseFromData}","page":"API","title":"LegendGeSim.simulate","text":"simulate(wf, elec_chain, noise_model)\n\nRDWaveform, GenericElecChain, NoiseFromData -> RDWaveform\n\nSimulate effects of the electronics chain on the waveform     modelling noise based on baselines extracted from data     (note: also takes preamp offset into account)\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.simulate-Tuple{RadiationDetectorSignals.RDWaveform, LegendGeSim.GenericFADC}","page":"API","title":"LegendGeSim.simulate","text":"simulate(wf, fadc)\n\nRDWaveform, GenericFADC -> RDWaveform\n\nSimulate effects of FADC module <fadc> on the waveform <wf>     (sampling and digitization)\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.simulate-Tuple{RadiationDetectorSignals.RDWaveform, LegendGeSim.GenericPreAmp}","page":"API","title":"LegendGeSim.simulate","text":"simulate(wf, preamp)\n\nRDWaveform, GenericPreAmp -> RDWaveform\n\nSimulate the effecs of the preamp on the waveform.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.simulate-Tuple{RadiationDetectorSignals.RDWaveform, LegendGeSim.TrapFilter}","page":"API","title":"LegendGeSim.simulate","text":"simulate(wf, trap_filter)\n\nRDWaveform, TrapFilter -> Int, Real \n\nSimulate the results of applying <trapfilter> to <wf> Returns the index on which <wf> triggered, and the estimated     online energy based on <trapfilter> output.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.simulate-Union{Tuple{U}, Tuple{RadiationDetectorSignals.RDWaveform{var\"#s13\", U, TV, UV} where {var\"#s13\", TV<:AbstractVector{var\"#s13\"}, UV<:AbstractVector{U}}, Int64, LegendGeSim.GenericDAQ}} where U","page":"API","title":"LegendGeSim.simulate","text":"simulate(wf, trigger_index, daq)\n\nRDWaveform, Int, DAQ -> RDWaveform\n\nSimulate how the DAQ stores the waveform after it receives a trigger.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.simulate_noise-Tuple{RadiationDetectorSignals.RDWaveform, LegendGeSim.NoiseFromData}","page":"API","title":"LegendGeSim.simulate_noise","text":"simulate_noise(wf, noise_model)\n\nRDWaveform, NoiseFromData -> RDWaveform\n\nSimulate noise and offset by picking a random baseline from the baseline catalog     contained in <noise_model> and slapping it on top of the given waveform <wf>.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.simulate_noise-Tuple{RadiationDetectorSignals.RDWaveform, LegendGeSim.PreAmp}","page":"API","title":"LegendGeSim.simulate_noise","text":"simulate_noise(wf, preamp)\n\nRDWaveform, PreAmp -> RDWaveform\n\nSimulate effects of the preamplifier <preamp> on the given waveform <wf>.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.simulate_waveforms-Tuple{TypedTables.Table, SolidStateDetectors.Simulation, LegendGeSim.SSDSimulator}","page":"API","title":"LegendGeSim.simulate_waveforms","text":"simulate_waveforms(stp_events, detector)\n\nTable, SolidStateDetectors.Simulation -> Table, Table     \n\nSimulate pulses based on events given in <stp_events>     using the given SSD detector simulation instance <detector>\n\nConstructs and returns a table with resulting pulses and a pss truth table     (may be abolished in the future as unnecessary)    \n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.stp_to_pss-Tuple{TypedTables.Table, PropDicts.PropDict, LegendGeSim.Environment, LegendGeSim.PSSimulator, LegendGeSim.NoiseModel}","page":"API","title":"LegendGeSim.stp_to_pss","text":"stp_to_pss(stp_table, det_meta, env, ps_simulator, config_name)\n\nTable, PropDict, Env, PSSimulator, NoiseModel, AbstractString -> Table, Table    \n\nNOTE * Lukas removed NoiseModel from here for some reason (search for fano_noise in old files)\n\nSimulate waveforms based on stepping info given in <stptable>,      LEGEND detector metadata <detmeta>, environment settings given in <env>,     pulse shape simulation method <pssimulator>, and <noisemodel>\n\nThe output is a table with simulated pulses, and a table with simulation truth     (may be abolished in the future since basically corresponds to stp table)\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.trigger_threshold-Tuple{LegendGeSim.Trigger, LegendGeSim.GenericPreAmp, LegendGeSim.NoiseFromData}","page":"API","title":"LegendGeSim.trigger_threshold","text":"trigger_threshold(trigger, preamp, noise_model)\n\nTrigger, GenericPreAmp, NoiseFromData -> Real \n\nIn NoiseFromData setting, if trigger threshold in keV is not provided,     it is calculated based on noise levels in the baselines contained in     <noise_model>. Otherwise the final threshold is calculated based on <preamp> gain.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendGeSim.trigger_threshold-Tuple{LegendGeSim.Trigger, LegendGeSim.GenericPreAmp, Union{LegendGeSim.NoiseFromSim, LegendGeSim.NoiseNone}}","page":"API","title":"LegendGeSim.trigger_threshold","text":"trigger_threshold(trigger, preamp, ::NoiseFromSim)\n\nTrigger, GenericPreAmp -> Real \n\nIn NoiseFromSim setting, non-zero trigger threshold in keV MUST be given by the user. Calculate final threshold based the value contained in <trigger>, and <preamp> gain.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"EditURL = \"simulate_fields_lit.jl\"","category":"page"},{"location":"tutorials/simulate_fields/#Simulate-Fields","page":"Simulate Fields","title":"Simulate Fields","text":"","category":"section"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"You can also download this tutorial as a Jupyter notebook and a plain Julia source file.","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"To obtain JSONs for all LEGEND detectors you can clone the repository legend-detectors. The JSONs can be found under germanium/diodes. You may also create your custom detector JSON file as long as it follows the LEGEND detector metadata format (see README in diodes/).","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"Here we will use public example JSONs from LegendTestData","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"using LegendGeSim\nusing Plots","category":"page"},{"location":"tutorials/simulate_fields/#Get-detector-metadata-JSON-from-legend-test-data","page":"Simulate Fields","title":"Get detector metadata JSON from legend-test-data","text":"","category":"section"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"using LegendTestData","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"germanium_testdata_path = joinpath(legend_test_data_path(), \"data\", \"legend\", \"metadata\", \"hardware\", \"detectors\", \"germanium\")\n\ndetector_name = \"V99000A\"\ndetector_metadata_filename = joinpath(germanium_testdata_path, \"diodes\", detector_name*\".json\");\nnothing #hide","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"Alternatively, enter your own path to a real LEGEND detector JSON (see manual on Field Simulation for more details)","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"detector_metadata_filename = \"path/to/V04545A.json\"","category":"page"},{"location":"tutorials/simulate_fields/#Settings","page":"Simulate Fields","title":"Settings","text":"","category":"section"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"See manual on Field Simulation for a detailed explanation of environment and simulation settings","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"environment_settings = Dict(\n    \"crystal_temperature_in_K\" => 77,\n    \"medium\" => \"vacuum\",\n    \"dl\" => \"vendor\" # optional, default 0\n);\nnothing #hide","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"simulation_settings = Dict(\n    \"method\" => \"SSD\",\n    \"cached_name\" => \"\", # a non-empty string will cache the simulation results\n    \"crystal_metadata_path\" => joinpath(germanium_testdata_path, \"crystals\")\n);\nnothing #hide","category":"page"},{"location":"tutorials/simulate_fields/#Simulation-with-SolidStateDetectors","page":"Simulate Fields","title":"Simulation with SolidStateDetectors","text":"","category":"section"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"sim_ssd = LegendGeSim.simulate_fields(detector_metadata_filename, environment_settings, simulation_settings; overwrite=true)","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"The output of simulate_fields() in case of SSD will be a SolidStateDetector object.","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"Below are some examples of what you can do with it","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"LegendGeSim.capacitance_matrix(sim_ssd)","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"Using built-in SolidStateDetectors.jl functionality","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"using LegendGeSim: SolidStateDetectors as SSD","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"SSD.is_depleted(sim_ssd.point_types)","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"SSD.estimate_depletion_voltage(sim_ssd)","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"plot(\n    plot(sim_ssd.point_types, full_det = true),\n    plot(sim_ssd.electric_potential, full_det = true),\n    plot(sim_ssd.weighting_potentials[1], full_det = true),\n    plot(sim_ssd.weighting_potentials[2], full_det = true),\n    begin\n        plot(sim_ssd.electric_field, full_det = true)\n        SSD.plot_electric_fieldlines!(sim_ssd, full_det = true)\n    end,\n    size = (1000, 800), layout = (3, 2)\n)\n\nsavefig(\"SSD_multiplot.svg\"); nothing # hide","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"(Image: SSD_multiplot)","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"Consult SolidStateDetectors.jl tutorials for more operations on the SolidStateDetector object","category":"page"},{"location":"tutorials/simulate_fields/#Simulation-with-Fieldgen","page":"Simulate Fields","title":"Simulation with Fieldgen","text":"","category":"section"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"The same simulation settings can be used for siggen, changing only the \"method\" settings to \"siggen\" (or \"fieldgen\") and loading the MJDSigGen package.","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"using MJDSigGen\nsimulation_settings_siggen = deepcopy(simulation_settings)\nsimulation_settings_siggen[\"method\"] = \"fieldgen\"","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"The same function simulate_fields is used with identical inputs as in case of SSD.","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"sim_fieldgen = LegendGeSim.simulate_fields(detector_metadata_filename, environment_settings, simulation_settings_siggen; overwrite=true)","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"The output of simulate_fields() in case of Fieldgen will be a SigGenSetup object from MJDSigGen.jl.","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"The same function as in the SSD example can be used to obtain fieldgen simulated capacitance matrix","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"LegendGeSim.capacitance_matrix(sim_fieldgen)","category":"page"},{"location":"tutorials/simulate_fields/#Alternative","page":"Simulate Fields","title":"Alternative","text":"","category":"section"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"Alternative input using an already existing impurity_profile and offset_in_mm as input fields","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"simulation_settings_siggen1 = Dict(\n    \"method\" => \"fieldgen\",\n    \"cached_name\" => \"\", # a non-empty string will cache the simulation result\n    \"impurity_profile\" => \"cache/V99000.dat\",\n    \"offset_in_mm\" => 0\n);\nnothing #hide","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"sim_fieldgen = LegendGeSim.simulate_fields(detector_metadata_filename, environment_settings, simulation_settings_siggen1; overwrite=true)","category":"page"},{"location":"tutorials/simulate_fields/#Compare-SSD-to-Fieldgen","page":"Simulate Fields","title":"Compare SSD to Fieldgen","text":"","category":"section"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"We can construct wlectric and weighting potential based on Fieldgen results in the same format as SSD","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"e_pot = SSD.ElectricPotential(sim_fieldgen);\nw_pot = SSD.WeightingPotential(sim_fieldgen);\nnothing #hide","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"ToDo: same units for SSD and fieldgen","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"plot(\n    plot(sim_ssd.electric_potential, full_det = true, title = \"Electric potential via SSD\"),\n    plot(e_pot, full_det = true, title = \"Electric potential via Fieldgen\"),\n    size = (1000, 500), layout = (1, 2)\n)\n\nsavefig(\"SSD_vs_fieldgen_Epot.svg\"); nothing # hide","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"(Image: SSD_vs_fieldgen_Epot)","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"plot(\n    plot(sim_ssd.weighting_potentials[1], full_det = true, title = \"Weighting potential via SSD\"),\n    plot(w_pot, full_det = true, title = \"Weighting potential via fieldgen\"),\n    size = (1000, 500), layout = (1, 2)\n)\n\nsavefig(\"SSD_vs_fieldgen_Wpot.svg\"); nothing # hide","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"(Image: SSD_vs_fieldgen_Wpot)","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"","category":"page"},{"location":"tutorials/simulate_fields/","page":"Simulate Fields","title":"Simulate Fields","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"EditURL = \"simulate_realistic_waveforms_lit.jl\"","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/#Simulate-realistic-waveforms","page":"Simulate Realistic Waveforms","title":"Simulate realistic waveforms","text":"","category":"section"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"You can also download this tutorial as a Jupyter notebook and a plain Julia source file.","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"Here we will use an example pet file csv format from LegendTestData corresponding to the Public Inverted Coax.","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"using LegendGeSim\nusing Plots","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/#Get-inputs-from-legend-test-data","page":"Simulate Realistic Waveforms","title":"Get inputs from legend-test-data","text":"","category":"section"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"using LegendTestData","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/#Detector-metadata","page":"Simulate Realistic Waveforms","title":"Detector metadata","text":"","category":"section"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"ldsim_path = joinpath(legend_test_data_path(), \"data\", \"ldsim\")\n\ndetector_name = \"invcoax-metadata\"\ndetector_metadata_filename = joinpath(ldsim_path, detector_name*\".json\");\nnothing #hide","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"Alternatively, enter your own path to a real LEGEND detector JSON","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"detector_metadata_filename = \"path/to/V04545A.json\"","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/#PET-input-file","page":"Simulate Realistic Waveforms","title":"PET input file","text":"","category":"section"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"path_to_pet_file = joinpath(ldsim_path, \"single-invcoax-th228-geant4.csv\");\nnothing #hide","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/#Settings","page":"Simulate Realistic Waveforms","title":"Settings","text":"","category":"section"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"See manual on Field Simulation and Ideal Pulse Simulation for a detailed explanation of environment and simulation settings, as well as the noise model settings","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"environment_settings = Dict(\n    \"crystal_temperature_in_K\" => 77,\n    \"medium\" => \"vacuum\",\n);\nnothing #hide","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"simple settings for point charge simulation with dummy constant impurity","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"simulation_settings = Dict(\n    \"method\" => \"SSD\",\n    \"cached_name\" => \"\", # a non-empty string will cache the simulation results\n);\nnothing #hide","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"daq_settings = Dict(\n    \"preamp\" => Dict(\n        \"type\" => \"generic\",\n        \"t_decay_in_us\" => 43, # from V04545A HADES data\n        \"t_rise_in_ns\" => 100, # by eye\n        \"gain_ADC_eV\" => 0.0138, # by eye from V04545A HADES data FEP @ 36100 ADC\n        \"offset_in_ADC\" => 11900, # from V04545A HADES data mean() of baseline\n        \"noise_sigma_in_keV\" => 2 # by eye\n    ),\n    \"fadc\" => Dict(\n        \"type\" => \"generic\",\n        \"sampling_interval\" => 16 # ns, from HADES data\n    ),\n    \"trigger\" => Dict(\n        \"type\" => \"trapezoidal\",\n        \"window_lengths\" => [250,250,250],\n        \"threshold\" => 9 # keV\n    ),\n    \"daq\" => Dict(\n        \"type\" => \"generic\",\n        \"nsamples\" => 3748, # from HADES data\n        \"baseline_length\" => 1770 # by eye from data\n    )\n);\nnothing #hide","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"noise_model = Dict(\n    \"type\" => \"sim\"\n);\nnothing #hide","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/#Simulate-from-scratch-(pet-raw)","page":"Simulate Realistic Waveforms","title":"Simulate from scratch (pet -> raw)","text":"","category":"section"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"raw_table = LegendGeSim.simulate_raw(detector_metadata_filename, path_to_pet_file, environment_settings, simulation_settings, daq_settings, noise_model; n_waveforms=10)","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"plot(raw_table.waveform)","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"The file contains double the amount of waveforms (20) compared to what we asked to simulate (n_waveforms = 10). That's because at the pulse simulation level, n+ contact pulses are kept as well. The first 10 entries are p+ contact waveforms.","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"length(raw_table)","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"plot(raw_table.waveform[1:10], legend=false, title=\"only p+ contact waveforms\")","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"You can save simulated waveforms in a file that can be used later","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"using LegendHDF5IO","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"raw_name = \"cache/test_100wfs_raw.hdf5\"\nlh5open(raw_name, \"w\") do f\n    LegendHDF5IO.writedata(f.data_store, \"raw\", raw_table[1:10])\nend","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/#Simulate-from-pss-table-in-code","page":"Simulate Realistic Waveforms","title":"Simulate from pss table in code","text":"","category":"section"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"Rather that simulating from scratch pet->raw, you may also input an already ready pss table with ideal pulses, and simulate only the pss->raw step, i.e. the DAQ chain simulation","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"pss_table, pss_truth = LegendGeSim.simulate_pulses(detector_metadata_filename, path_to_pet_file, environment_settings, simulation_settings, noise_model; n_waveforms=10);\nnothing #hide","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"plot(pss_table.waveform[1:10])","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"raw_table1 = LegendGeSim.pss_to_raw(pss_table, pss_truth, daq_settings, noise_model)","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"plot(\n    plot(pss_table.waveform[1:10]),\n    plot(raw_table1.waveform[1:10]),\n    size=(800,400)\n)","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"Save the pss file for the next section","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"using LegendHDF5IO","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"pss_name = \"cache/test_100wfs_pss.hdf5\"\nlh5open(pss_name, \"w\") do f\n    LegendHDF5IO.writedata(f.data_store, \"pss/pss\", pss_table[1:10])\n    LegendHDF5IO.writedata(f.data_store, \"pss/truth\", pss_truth[1:10])\nend","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/#Simulate-from-pre-saved-pss-hdf5-file","page":"Simulate Realistic Waveforms","title":"Simulate from pre-saved pss hdf5 file","text":"","category":"section"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"Rather than simulating form scratch pet->raw, you may input the name of a pre-saved pss file containing pss and pss truth information","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"raw_table2 = LegendGeSim.pss_to_raw(pss_name, daq_settings, noise_model)","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"","category":"page"},{"location":"tutorials/simulate_realistic_waveforms/","page":"Simulate Realistic Waveforms","title":"Simulate Realistic Waveforms","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/LegendGeSim/#The-LEGEND-Germanium-Simulation-Chain","page":"The LEGEND Germanium Simulation Chain","title":"The LEGEND Germanium Simulation Chain","text":"","category":"section"},{"location":"man/LegendGeSim/","page":"The LEGEND Germanium Simulation Chain","title":"The LEGEND Germanium Simulation Chain","text":"LegendGeSim is a multi-purpose tool that can be used for anything from visualizing detector geometry to simulating raw files with realistic data-like waveforms that mimic data and are compatible with data processing tools.","category":"page"},{"location":"man/LegendGeSim/","page":"The LEGEND Germanium Simulation Chain","title":"The LEGEND Germanium Simulation Chain","text":"The path towards a data-like raw hdf5 file starts from simulating the detector itself for given geometry and environmental conditions; then simulating pulses based on given information on energy depositions; and finally, simulating the effects of the DAQ chain.","category":"page"},{"location":"man/LegendGeSim/","page":"The LEGEND Germanium Simulation Chain","title":"The LEGEND Germanium Simulation Chain","text":"(Image: LegendGeSim)","category":"page"},{"location":"man/LegendGeSim/","page":"The LEGEND Germanium Simulation Chain","title":"The LEGEND Germanium Simulation Chain","text":"The chain can be used for any step in this path independently: visualize detector geometry, simulate fields, simulate ideal pulses, or finally, simulate realistic data-like waveforms. Each step is described in a corresponding Manual and Tutorial section.","category":"page"},{"location":"man/LegendGeSim/","page":"The LEGEND Germanium Simulation Chain","title":"The LEGEND Germanium Simulation Chain","text":"The tiers of the simulation are pet->stp->pss->raw where","category":"page"},{"location":"man/LegendGeSim/","page":"The LEGEND Germanium Simulation Chain","title":"The LEGEND Germanium Simulation Chain","text":"pet tier: input information on position, energy amd time of the depositions\nstp tier: stepping information, currently clustering, removing events reconstructed outside of the detector and with zero energy. In the future things like pile-up may go here\npss tier: ideal pulses simulated by SolidStateDetectors or siggen\nraw tier: simulated realistic waveforms in hdf5 format that mimics data raw tier","category":"page"},{"location":"man/LegendGeSim/","page":"The LEGEND Germanium Simulation Chain","title":"The LEGEND Germanium Simulation Chain","text":"(Image: PSSFlow)","category":"page"},{"location":"man/ideal_pulse_simulation/#Ideal-Pulse-Simulation","page":"Ideal Pulse Simulation","title":"Ideal Pulse Simulation","text":"","category":"section"},{"location":"man/ideal_pulse_simulation/","page":"Ideal Pulse Simulation","title":"Ideal Pulse Simulation","text":"As inputs to ideal pulse simulation you should provide","category":"page"},{"location":"man/ideal_pulse_simulation/","page":"Ideal Pulse Simulation","title":"Ideal Pulse Simulation","text":"LEGEND detector metadata\nPET input file\nEnvironment settings\nSimulation settings\nNoise model","category":"page"},{"location":"man/ideal_pulse_simulation/#Example","page":"Ideal Pulse Simulation","title":"Example","text":"","category":"section"},{"location":"man/ideal_pulse_simulation/","page":"Ideal Pulse Simulation","title":"Ideal Pulse Simulation","text":"detector_metadata_filename = \"path/to/legend-detectors/germanium/diodes/V04545A.json\"\n\npet_input_file = \"/lfs/l1/legend/detector_char/enr/hades/simulations/legend-g4simple-simulation/simulations/V04545A/am_HS1/top_46r_4z/hdf5/sim-V04545A-am_HS1-top-46r-4z-01.hdf5\"\n\nenvironment_settings = Dict(\n    \"crystal_temperature_in_K\" => 77, \n    \"medium\" => \"vacuum\", \n    \"dl\" => \"vendor\" # optional, default 0\n    \"operating_voltage_in_V\" => 5000, # optional, default recV from metadata\n)\n\nsimulation_settings = Dict(\n    \"method\" => \"SSD\",\n    \"cached_name\" => \"test\",\n    \"crystal_metadata_path\" => \"path/to/legend-detectors/germanium/crystals\",\n    \"time_step\" => 2, #ns\n    \"diffusion\" => true,\n    \"self-repulsion\" => true,\n    \"num_carriers\" => 10\n)\n\nnoise_model = Dict(\n    \"type\" => \"sim\"\n)\n\npss_table, pss_truth = LegendGeSim.simulate_pulses(detector_metadata_filename, pet_input_file, environment_settings, simulation_settings, noise_model; n_waveforms=100)","category":"page"},{"location":"man/ideal_pulse_simulation/","page":"Ideal Pulse Simulation","title":"Ideal Pulse Simulation","text":"The optional variable n_waveforms defines how many waveforms will be simulted based on the given pet file. Not providing the variable will default 0 meaning, simulate all waveforms in the pet input file.","category":"page"},{"location":"man/ideal_pulse_simulation/","page":"Ideal Pulse Simulation","title":"Ideal Pulse Simulation","text":"The output: pss_table contains the following fields:","category":"page"},{"location":"man/ideal_pulse_simulation/","page":"Ideal Pulse Simulation","title":"Ideal Pulse Simulation","text":"channel: currently, ID of the contact (1 for p+ contact, 2 for n+ contact)\nievt: event number\nwaveform: waveform in format of RDWaweform from RadiationDetectorSignals.jl. Contains fields time and signal.","category":"page"},{"location":"man/ideal_pulse_simulation/","page":"Ideal Pulse Simulation","title":"Ideal Pulse Simulation","text":"pss_truth contains a copy of the information in the pet input file for convenience (to compare)","category":"page"},{"location":"man/ideal_pulse_simulation/#1.-LEGEND-detector-metadata","page":"Ideal Pulse Simulation","title":"1. LEGEND detector metadata","text":"","category":"section"},{"location":"man/ideal_pulse_simulation/","page":"Ideal Pulse Simulation","title":"Ideal Pulse Simulation","text":"To obtain JSONs for all LEGEND detectors you can clone the repository legend-detectors. The JSONs can be found under germanium/diodes. You may also create your custom detector JSON file as long as it follows the LEGEND detector metadata format (see README in diodes/).","category":"page"},{"location":"man/ideal_pulse_simulation/#2.-PET-input-file","page":"Ideal Pulse Simulation","title":"2. PET input file","text":"","category":"section"},{"location":"man/ideal_pulse_simulation/","page":"Ideal Pulse Simulation","title":"Ideal Pulse Simulation","text":"The pet input file contains information on position, energy amd time of the depositions.","category":"page"},{"location":"man/ideal_pulse_simulation/","page":"Ideal Pulse Simulation","title":"Ideal Pulse Simulation","text":"Current available formats:","category":"page"},{"location":"man/ideal_pulse_simulation/","page":"Ideal Pulse Simulation","title":"Ideal Pulse Simulation","text":"g4simple output in hdf5 format. The g4simple simulations of HADES characterization data are available on MPIK under /lfs/l1/legend/detector_char/enr/hades/simulations/legend-g4simple-simulation/simulations/. Consult the legend-g4simple-simulation package to simulate your own custom pet input for given detector and source.\nGeant4 output in csv format. See example in legend-testdata under data/ldsim/single-invcoax-th228-geant4.csv","category":"page"},{"location":"man/ideal_pulse_simulation/","page":"Ideal Pulse Simulation","title":"Ideal Pulse Simulation","text":"Here we will use an example pet file csv format from LegendTestData corresponding to the Public Inverted Coax.","category":"page"},{"location":"man/ideal_pulse_simulation/#3.-Environemnt-settings","page":"Ideal Pulse Simulation","title":"3. Environemnt settings","text":"","category":"section"},{"location":"man/ideal_pulse_simulation/","page":"Ideal Pulse Simulation","title":"Ideal Pulse Simulation","text":"See Field Simulation manual for more details","category":"page"},{"location":"man/ideal_pulse_simulation/#4.-Simulation-settings","page":"Ideal Pulse Simulation","title":"4. Simulation settings","text":"","category":"section"},{"location":"man/ideal_pulse_simulation/","page":"Ideal Pulse Simulation","title":"Ideal Pulse Simulation","text":"Simulation settings contain settings related to field simulation (see Field Simulation manual) + pulse simulation settings.","category":"page"},{"location":"man/ideal_pulse_simulation/","page":"Ideal Pulse Simulation","title":"Ideal Pulse Simulation","text":"Options related to pulse simulation:","category":"page"},{"location":"man/ideal_pulse_simulation/","page":"Ideal Pulse Simulation","title":"Ideal Pulse Simulation","text":"\"time_step\": time step in nanoseconds, default 1ns\n\"diffusion\": setting for cloud charge simulation. Default false (point charges)\n\"self_repulsion\": setting for cloud charge simulation. Default false (point charges)\n\"number_of_carriers\": setting for cloud charge simulation. Default 1 (point charges)","category":"page"},{"location":"man/ideal_pulse_simulation/#5.-Noise-model","page":"Ideal Pulse Simulation","title":"5. Noise model","text":"","category":"section"},{"location":"man/ideal_pulse_simulation/","page":"Ideal Pulse Simulation","title":"Ideal Pulse Simulation","text":"At this stage of the simulation, the noise model regards fano noise of the germanium crystal. The options are simply to simulate the noise or not.","category":"page"},{"location":"man/ideal_pulse_simulation/","page":"Ideal Pulse Simulation","title":"Ideal Pulse Simulation","text":"If you would like to simulate fano noise, provide","category":"page"},{"location":"man/ideal_pulse_simulation/","page":"Ideal Pulse Simulation","title":"Ideal Pulse Simulation","text":"noise_model = Dict( \"type\" => \"sim\" )","category":"page"},{"location":"man/ideal_pulse_simulation/","page":"Ideal Pulse Simulation","title":"Ideal Pulse Simulation","text":"If you do not want to simulate fano noise, simply do not provide noise_model to to simulate_pulses() (it will default to \"type\" => \"none\")","category":"page"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#LegendGeSim.jl","page":"Home","title":"LegendGeSim.jl","text":"","category":"section"},{"location":"man/realistic_waveform_simulation/#Realistic-Waveform-Simulation","page":"Realistic Waveform Simulation","title":"Realistic Waveform Simulation","text":"","category":"section"},{"location":"man/realistic_waveform_simulation/","page":"Realistic Waveform Simulation","title":"Realistic Waveform Simulation","text":"As inputs to realistic waveform simulation you should provide","category":"page"},{"location":"man/realistic_waveform_simulation/","page":"Realistic Waveform Simulation","title":"Realistic Waveform Simulation","text":"LEGEND detector metadata\nPET input file\nEnvironment settings\nSimulation settings\nDAQ settings\nNoise model","category":"page"},{"location":"man/realistic_waveform_simulation/#Example","page":"Realistic Waveform Simulation","title":"Example","text":"","category":"section"},{"location":"man/realistic_waveform_simulation/","page":"Realistic Waveform Simulation","title":"Realistic Waveform Simulation","text":"detector_metadata_filename = \"path/to/legend-detectors/germanium/diodes/V04545A.json\"\n\npet_input_file = \"/lfs/l1/legend/detector_char/enr/hades/simulations/legend-g4simple-simulation/simulations/V04545A/am_HS1/top_46r_4z/hdf5/sim-V04545A-am_HS1-top-46r-4z-01.hdf5\"\n\nenvironment_settings = Dict(\n    \"crystal_temperature_in_K\" => 77, \n    \"medium\" => \"vacuum\", \n    \"dl\" => \"vendor\" # optional, default 0\n    \"operating_voltage_in_V\" => 5000, # optional, default recV from metadata\n)\n\nsimulation_settings = Dict(\n    \"method\" => \"SSD\",\n    \"cached_name\" => \"test\",\n    \"crystal_metadata_path\" => \"path/to/legend-detectors/germanium/crystals\",\n    \"time_step\" => 2, #ns\n    \"diffusion\" => true,\n    \"self-repulsion\" => true,\n    \"num_carriers\" => 10\n)\n\ndaq_settings = Dict(\n    \"preamp\" => Dict(\n        \"type\" => \"generic\",\n        \"t_decay_in_us\" => 43, # from V04545A HADES data\n        \"t_rise_in_ns\" => 100, # by eye\n        \"gain_ADC_eV\" => 0.0138, # by eye from V04545A HADES data FEP @ 36100 ADC\n        \"offset_in_ADC\" => 11900, # from V04545A HADES data mean() of baseline\n        \"noise_sigma_in_keV\" => 2 # by eye\n    ),\n    \"fadc\" => Dict(\n        \"type\" => \"generic\",\n        \"sampling_interval\" => 16 # ns, from HADES data\n    ),\n    \"trigger\" => Dict(\n        \"type\" => \"trapezoidal\",        \n        \"window_lengths\" => [250,250,250],\n        \"threshold\" => 9 # keV\n    ),\n    \"daq\" => Dict(\n        \"type\" => \"generic\",\n        \"nsamples\" => 3748, # from HADES data\n        \"baseline_length\" => 1770 # by eye from data\n    )\n)\n\nnoise_model = Dict(\n    \"type\" => \"sim\"\n)\n\nraw_table = LegendGeSim.simulate_raw(detector_metadata_filename, pet_input_file, environment_settings, simulation_settings, daq_settings, noise_model; n_waveforms=100)","category":"page"},{"location":"man/realistic_waveform_simulation/","page":"Realistic Waveform Simulation","title":"Realistic Waveform Simulation","text":"The optional variable n_waveforms defines how many waveforms will be simulted based on the given pet file. Not providing the variable will default 0 meaning, simulate all waveforms in the pet input file.","category":"page"},{"location":"man/realistic_waveform_simulation/","page":"Realistic Waveform Simulation","title":"Realistic Waveform Simulation","text":"The output raw_table is a Julia Table, currently mimicking HADES raw data format. It contains the following fields:","category":"page"},{"location":"man/realistic_waveform_simulation/","page":"Realistic Waveform Simulation","title":"Realistic Waveform Simulation","text":"baseline: baseline offset of each waveform in units of ADC\nchannel: currently, ID of the contact (1 for p+ contact, 2 for n+ contact)\nenergy: online energy estimated from the trap filter trigger. Currently in units of keV, data raw seems to be in ADC (WIP)\nievt: event number\nnumtraces: number of triggered detectors (always 1 for HADES)\npacket_id: means to packet losses (always 0 in simulation)\ntimestamp: currently frist MC truth hit time of each event\ntracelist: lists of ADCs that triggered, 1 for HADES all the time\nwaveform: waveform in format of RDWaweform from RadiationDetectorSignals.jl. Contains fields time and signal\nwf_max: maximum of each waveform\nwf_std: standard deviation of each waveform (full waveform not just baseline)","category":"page"},{"location":"man/realistic_waveform_simulation/","page":"Realistic Waveform Simulation","title":"Realistic Waveform Simulation","text":"This format is digestible by pygama build_dsp() with HADES configuration JSON file.","category":"page"},{"location":"man/realistic_waveform_simulation/#1.-LEGEND-detector-metadata","page":"Realistic Waveform Simulation","title":"1. LEGEND detector metadata","text":"","category":"section"},{"location":"man/realistic_waveform_simulation/","page":"Realistic Waveform Simulation","title":"Realistic Waveform Simulation","text":"To obtain JSONs for all LEGEND detectors you can clone the repository legend-detectors. The JSONs can be found under germanium/diodes. You may also create your custom detector JSON file as long as it follows the LEGEND detector metadata format (see README in diodes/).","category":"page"},{"location":"man/realistic_waveform_simulation/#2.-PET-input-file","page":"Realistic Waveform Simulation","title":"2. PET input file","text":"","category":"section"},{"location":"man/realistic_waveform_simulation/","page":"Realistic Waveform Simulation","title":"Realistic Waveform Simulation","text":"See Ideal Pulse Simulation manual for details on the contents and format of the PET input file.","category":"page"},{"location":"man/realistic_waveform_simulation/#3.-Environment-settings","page":"Realistic Waveform Simulation","title":"3. Environment settings","text":"","category":"section"},{"location":"man/realistic_waveform_simulation/","page":"Realistic Waveform Simulation","title":"Realistic Waveform Simulation","text":"See Field Simulation manual for more details","category":"page"},{"location":"man/realistic_waveform_simulation/#4.-Simulation-settings","page":"Realistic Waveform Simulation","title":"4. Simulation settings","text":"","category":"section"},{"location":"man/realistic_waveform_simulation/","page":"Realistic Waveform Simulation","title":"Realistic Waveform Simulation","text":"Simulation settings contain settings related to field simulation and pulse simulation. See Field Simulation and Ideal Pulse Simulation manuals for more details","category":"page"},{"location":"man/realistic_waveform_simulation/#5.-DAQ-settings","page":"Realistic Waveform Simulation","title":"5. DAQ settings","text":"","category":"section"},{"location":"man/realistic_waveform_simulation/","page":"Realistic Waveform Simulation","title":"Realistic Waveform Simulation","text":"Current settings mimic the HADES DAQ setup. They contain the following fields:","category":"page"},{"location":"man/realistic_waveform_simulation/","page":"Realistic Waveform Simulation","title":"Realistic Waveform Simulation","text":"\"preamp\": parameters modelling the preamplifier.\n\"type\": this field defines the rest of the parameters in the \"preamp\" field corresponding to given preamplifier type. Current available preamplifier type is \"generic\", which defines a simple CR preamlifier. In the future other more complex models might be available. The following parameters in \"preamp\" describe a type \"generic\" preamplifier\n\"t_decay_in_us\": decay time constant in microseconds. Default 50 us.\n\"t_rise_in_ns\": rise time constant in nanoseconds. Default 100 ns.\n\"gain_ADC_eV\": preamplifier gain in units ADC/eV. Defined this way for convenience e.g. estimating gain based on the ADC value of a peak with known eV energy such as FEP etc. Default  0.138 ADC/eV.\n\"offset_in_ADC\": waveform baseline offset in units of ADC. Alternative input \"offset_in_keV\" to define offset in units of keV. Default 0.\n\"noise_sigma_in_ADC\": Gaus noise sigma in units of ADC. Alternative input \"noise_sigma_in_keV to define Gaus noise sigma in units of keV. Default 0.\nWARNING: the implementation is janky. If you do not want to simulate noise, do NOT provide noise sigma in the preamplifier settings. Even if you provide noise settings for no noise (see below), if the sigma is non-zero, the noise WILL be added. WIP to fix this bad implementation.\n\"fadc\": parameters modelling the FADC component of the DAQ chain.\n\"type\": this field defines the rest of the parameters in the \"fadc\" field corresponding to given FADC type.  Current available FADC type is \"generic\", which defines a very simple dummy FADC component. In the future realistic FlashCam model might be available. The following parameters in \"fadc\" describe a type \"generic\" FADC\n\"sampling_interval\": sampling interval in nanoseconds. For example, in HADES data we see a time step of 16 ns. No default value\n\"sampling_rate\": alternative input to \"sampling_interval\", sampling frequency of the FADC in MHz. No default value. One or the other parameters has to be provided.\nThe \"generic\" type FADC is a very dummy model. It \"samples\" the waveform by simply picking every Nth point of the waveform based on the given sampling interval/frequency. For this you need to make sure that the time step of the simulated pulse is smaller than sampling interval. If the time step of the waveform does not fit into sampling interval in integer amount, the step will be rounded to int.   The digitizing is simulated by converting the values to Int16. If the waveform ADC value surpasses maximum of Int16, the waveform will be saturated.\n\"trigger\": parameteres modelling the trigger component of the DAQ chain.\n\"type\": this field defines the rest of the parameters in the \"trigger\" field corresponding to given Trigger type. Current available Trigger type is \"trapezoidal\",  which defines a trapezoidal filter trigger. The following parameters in \"trigger\" describe a type \"trapezoidal\" Trigger\n\"window_lengths\": list of three trap filter window lengths in number of samples e.g. [250,250,250]. No default value.\n\"threshold\": threshold in keV. No default value.\nPulses that don't pass the trigger threshold\n\"daq\": parameters modelling data acquisition to disk.\n\"type\": this field defines the rest of the parameters in \"daq\" field corresponding to given DAQ type. Current available DAQ type is \"generic\", which defines a simple dummy DAQ. The following parameters in \"daq\" describe a type \"generic\" DAQ\n\"nsamples\": number of samples in the waveform to save to disk. E.g. in HADES data there are 3748 samples in each waveform\n\"baseline_length\": number of samples of baseline to save before the trigger point.","category":"page"},{"location":"man/realistic_waveform_simulation/#6.-Noise-model","page":"Realistic Waveform Simulation","title":"6. Noise model","text":"","category":"section"},{"location":"tutorials/detector_geometry/","page":"Detector Geometry","title":"Detector Geometry","text":"EditURL = \"detector_geometry_lit.jl\"","category":"page"},{"location":"tutorials/detector_geometry/#Visualize-Detector-Geometry","page":"Detector Geometry","title":"Visualize Detector Geometry","text":"","category":"section"},{"location":"tutorials/detector_geometry/","page":"Detector Geometry","title":"Detector Geometry","text":"You can also download this tutorial as a Jupyter notebook and a plain Julia source file.","category":"page"},{"location":"tutorials/detector_geometry/","page":"Detector Geometry","title":"Detector Geometry","text":"As input you should provide the path to a LEGEND detector metadata JSON file e.g.","category":"page"},{"location":"tutorials/detector_geometry/","page":"Detector Geometry","title":"Detector Geometry","text":"detector_metadata_filename = \"path/to/V04545A.json\"","category":"page"},{"location":"tutorials/detector_geometry/","page":"Detector Geometry","title":"Detector Geometry","text":"To obtain JSONs for all LEGEND detectors you can clone the repository legend-detectors. The JSONs can be found under germanium/diodes. You may also create your custom detector JSON file as long as it follows the LEGEND detector metadata format (see README in diodes/).","category":"page"},{"location":"tutorials/detector_geometry/","page":"Detector Geometry","title":"Detector Geometry","text":"Here we will use a Public Inverted Coax example JSON from LegendTestData","category":"page"},{"location":"tutorials/detector_geometry/","page":"Detector Geometry","title":"Detector Geometry","text":"# Get detector metadata JSON from `legend-test-data`\n\nusing LegendTestData\n\nldsim_path = joinpath(legend_test_data_path(), \"data\", \"ldsim\")\n\ndetector_name = \"invcoax-metadata\"\ndetector_metadata_filename = joinpath(ldsim_path, detector_name*\".json\");\nnothing #hide","category":"page"},{"location":"tutorials/detector_geometry/#View-geometry","page":"Detector Geometry","title":"View geometry","text":"","category":"section"},{"location":"tutorials/detector_geometry/","page":"Detector Geometry","title":"Detector Geometry","text":"using LegendGeSim\nusing Plots","category":"page"},{"location":"tutorials/detector_geometry/","page":"Detector Geometry","title":"Detector Geometry","text":"The function LEGEND_SolidStateDetector will create an \"empty\" SolidStateDetector object from SolidStateDetectors.jl only for the purpose of viewing geometry. You will see information such as bias voltage, but that is irrelevant at this stage, and the fields are not simulated at this point.","category":"page"},{"location":"tutorials/detector_geometry/","page":"Detector Geometry","title":"Detector Geometry","text":"detector = LegendGeSim.LEGEND_SolidStateDetector(detector_metadata_filename)\n\nplot(detector, aspect_ratio=1.0, camera=(20,20), size=(450,450), title=detector_name)\n\nsavefig(\"tutorial_det.svg\"); nothing # hide","category":"page"},{"location":"tutorials/detector_geometry/","page":"Detector Geometry","title":"Detector Geometry","text":"(Image: tutorial_det)","category":"page"},{"location":"tutorials/detector_geometry/","page":"Detector Geometry","title":"Detector Geometry","text":"","category":"page"},{"location":"tutorials/detector_geometry/","page":"Detector Geometry","title":"Detector Geometry","text":"This page was generated using Literate.jl.","category":"page"}]
}
